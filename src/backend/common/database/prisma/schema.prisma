// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native"]
}

datasource db {
  provider = "postgresql"
}

// ==================== ENUMS ====================

enum Role {
  USER
  ADMIN
}

enum EventStatus {
  UPCOMING
  ON_SALE
  SOLD_OUT
  CANCELLED
  COMPLETED
}

enum SeatType {
  REGULAR
  VIP
  PREMIUM
}

enum SectionType {
  ASSIGNED
  GENERAL
}

enum SeatStatus {
  AVAILABLE
  RESERVED
  BOOKED
  BLOCKED
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  FAILED
}

enum PaymentStatus {
  PENDING
  SUCCESS
  FAILED
  REFUNDED
}

enum ReservationStatus {
  ACTIVE
  CONFIRMED
  EXPIRED
  CANCELLED
}

// ==================== MODELS ====================

/// Venues table - stores event center information with capacities
model Venue {
  id        BigInt   @id @default(autoincrement()) @map("venue_id")
  name      String   @unique @db.VarChar(255)
  address   String?  @db.VarChar(500)
  city      String?  @db.VarChar(100)
  state     String?  @db.VarChar(100)
  country   String?  @db.VarChar(100)
  capacity  Int
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamp(6)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamp(6)

  // Relations
  events         Event[]
  eventSections  EventSection[]
  venueSections  VenueSection[]

  @@index([name], map: "idx_venues_name")
  @@index([city], map: "idx_venues_city")
  @@map("venues")
}

/// VenueSections - template sections for registered venues
model VenueSection {
  id            BigInt      @id @default(autoincrement()) @map("venue_section_id")
  venueId       BigInt      @map("venue_id")
  name          String      @db.VarChar(100)
  type          SectionType @default(ASSIGNED)
  totalCapacity Int         @map("total_capacity")
  rows          Int?        @default(0) // For ASSIGNED seating layout
  seatsPerRow   Int?        @map("seats_per_row") // For ASSIGNED seating layout
  createdAt     DateTime    @default(now()) @map("created_at") @db.Timestamp(6)
  updatedAt     DateTime    @updatedAt @map("updated_at") @db.Timestamp(6)

  // Relations
  venue Venue @relation(fields: [venueId], references: [id], onDelete: Cascade)

  @@index([venueId])
  @@map("venue_sections")
}

/// Users table - stores user authentication and profile info
/// Users are global actors - no direct tenant assignment
model User {
  id        String   @id @default(uuid()) @map("user_id") @db.VarChar(50)
  email     String   @unique @db.VarChar(255)
  password  String   @db.VarChar(255)
  firstName String   @map("first_name") @db.VarChar(100)
  lastName  String   @map("last_name") @db.VarChar(100)
  role      Role     @default(USER)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamp(6)
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamp(6)

  // Relations
  createdEvents Event[]       @relation("EventCreator")
  bookings      Booking[]
  reservations  Reservation[]

  @@map("users")
}

/// Events table - stores event information
model Event {
  id             BigInt      @id @default(autoincrement()) @map("event_id")
  eventName      String      @map("event_name") @db.VarChar(255)
  eventDate      DateTime    @map("event_date") @db.Timestamp(6)
  venueId        BigInt?     @map("venue_id")
  venue          Venue?      @relation(fields: [venueId], references: [id])
  customVenue    String?     @map("custom_venue") @db.VarChar(255)
  totalSeats     Int         @map("total_seats")
  availableSeats Int         @map("available_seats")
  status         EventStatus @default(UPCOMING)
  saleStartTime  DateTime?   @map("sale_start_time") @db.Timestamp(6)
  isFree         Boolean     @default(false) @map("is_free")
  createdBy      String      @map("created_by") @db.VarChar(50)
  creator        User        @relation("EventCreator", fields: [createdBy], references: [id])
  createdAt      DateTime    @default(now()) @map("created_at") @db.Timestamp(6)

  // Relations
  seats         Seat[]
  bookings      Booking[]
  reservations  Reservation[]
  discounts     Discount[]
  eventSections EventSection[]

  // Indexes
  @@index([saleStartTime], map: "idx_events_sale_start_time")
  @@index([status], map: "idx_events_status")
  @@index([createdBy], map: "idx_events_created_by")
  @@index([venueId], map: "idx_events_venue_id")
  @@map("events")
}

/// EventSections - hybrid inventory units
model EventSection {
  id             BigInt      @id @default(autoincrement()) @map("section_id")
  eventId        BigInt      @map("event_id")
  venueId        BigInt?     @map("venue_id") // Set if section is inherited from a registered venue
  name           String      @db.VarChar(100)
  type           SectionType @default(ASSIGNED)
  price          Decimal     @db.Decimal(10, 2)
  totalCapacity  Int         @map("total_capacity")
  allocated      Int         @default(0)
  mapCoordinates Json?       @map("map_coordinates")
  createdAt      DateTime    @default(now()) @map("created_at") @db.Timestamp(6)
  updatedAt      DateTime    @updatedAt @map("updated_at") @db.Timestamp(6)

  // Relations
  event        Event         @relation(fields: [eventId], references: [id], onDelete: Cascade)
  venue        Venue?        @relation(fields: [venueId], references: [id])
  seats        Seat[]        @relation("SectionSeats")
  bookingSeats BookingSeat[]
  reservations Reservation[]

  @@index([eventId])
  @@index([venueId])
  @@map("event_sections")
}

/// Seats table - stores individual seat information for events
model Seat {
  id            BigInt     @id @default(autoincrement()) @map("seat_id")
  eventId       BigInt     @map("event_id")
  sectionId     BigInt?    @map("section_id")
  seatNumber    String     @map("seat_number") @db.VarChar(20)
  section       String?    @db.VarChar(50) // Legacy string field, consider deprecating or keeping for sync
  rowNumber     String?    @map("row_number") @db.VarChar(10)
  seatType      SeatType   @default(REGULAR) @map("seat_type")
  price         Decimal?   @db.Decimal(10, 2) // Optional, overrides section price
  status        SeatStatus @default(AVAILABLE)
  version       BigInt     @default(0) // Optimistic locking
  reservedBy    String?    @map("reserved_by") @db.VarChar(50)
  reservedUntil DateTime?  @map("reserved_until") @db.Timestamp(6)
  bookingId     BigInt?    @map("booking_id")
  createdAt     DateTime   @default(now()) @map("created_at") @db.Timestamp(6)

  // Relations
  event        Event         @relation(fields: [eventId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  eventSection EventSection? @relation("SectionSeats", fields: [sectionId], references: [id])
  bookingSeats BookingSeat[]
  reservations Reservation[]

  // Unique constraint and indexes
  @@unique([eventId, seatNumber], map: "uk_event_seat")
  @@index([eventId, status], map: "idx_seats_event_status")
  @@index([reservedUntil], map: "idx_seats_reserved_until")
  @@index([sectionId], map: "idx_seats_section_id")
  @@map("seats")
}

/// Bookings table - stores confirmed bookings
model Booking {
  id               BigInt        @id @default(autoincrement()) @map("booking_id")
  eventId          BigInt        @map("event_id")
  userId           String        @map("user_id") @db.VarChar(50)
  totalAmount      Decimal       @map("total_amount") @db.Decimal(10, 2)
  status           BookingStatus @default(PENDING)
  paymentId        String?       @map("payment_id") @db.VarChar(100)
  paymentStatus    PaymentStatus @default(PENDING) @map("payment_status")
  bookingReference String        @unique @map("booking_reference") @db.VarChar(50)
  createdAt        DateTime      @default(now()) @map("created_at") @db.Timestamp(6)
  confirmedAt      DateTime?     @map("confirmed_at") @db.Timestamp(6)

  // Relations
  event        Event         @relation(fields: [eventId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  user         User          @relation(fields: [userId], references: [id])
  bookingSeats BookingSeat[]

  // Indexes
  @@index([userId], map: "idx_bookings_user_id")
  @@index([bookingReference], map: "idx_bookings_reference")
  @@index([status], map: "idx_bookings_status")
  @@map("bookings")
}

/// BookingSeats table - many-to-many relationship between bookings and seats (and sections for GA)
model BookingSeat {
  id        BigInt  @id @default(autoincrement()) @map("booking_seat_id")
  bookingId BigInt  @map("booking_id")
  seatId    BigInt? @map("seat_id")
  sectionId BigInt? @map("section_id")
  quantity  Int     @default(1)
  price     Decimal @db.Decimal(10, 2)

  // Relations
  booking      Booking       @relation(fields: [bookingId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  seat         Seat?         @relation(fields: [seatId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  eventSection EventSection? @relation(fields: [sectionId], references: [id])

  // Unique constraint and indexes
  // Note: For GA, (bookingId, sectionId) might not be unique if we allow multiple lines, but usually merged.
  // We relax unique constraint or make it partial
  @@index([seatId], map: "idx_booking_seats_seat_id")
  @@index([sectionId], map: "idx_booking_seats_section_id")
  @@map("booking_seats")
}

/// Reservations table - stores temporary seat holds
model Reservation {
  id        BigInt            @id @default(autoincrement()) @map("reservation_id")
  seatId    BigInt?           @map("seat_id")
  eventId   BigInt            @map("event_id")
  userId    String            @map("user_id") @db.VarChar(50)
  sessionId String?           @map("session_id") @db.VarChar(100)
  sectionId BigInt?           @map("section_id")
  expiresAt DateTime          @map("expires_at") @db.Timestamp(6)
  status    ReservationStatus @default(ACTIVE)
  createdAt DateTime          @default(now()) @map("created_at") @db.Timestamp(6)

  // Relations
  event        Event         @relation(fields: [eventId], references: [id], onDelete: Cascade)
  seat         Seat?         @relation(fields: [seatId], references: [id])
  eventSection EventSection? @relation(fields: [sectionId], references: [id])
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([expiresAt], map: "idx_reservations_expires_at")
  @@index([seatId], map: "idx_reservations_seat_id")
  @@index([sectionId], map: "idx_reservations_section_id")
  @@index([userId], map: "idx_reservations_user_id")
  @@map("reservations")
}

/// IdempotencyKeys table - prevents duplicate operations
model IdempotencyKey {
  id         BigInt   @id @default(autoincrement()) @map("idempotency_key_id")
  key        String   @unique @map("idempotency_key") @db.VarChar(255)
  request    String   @db.Text
  response   String?  @db.Text
  statusCode Int      @map("status_code")
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamp(6)
  expiresAt  DateTime @map("expires_at") @db.Timestamp(6)

  @@index([key], map: "idx_idempotency_key")
  @@index([expiresAt], map: "idx_idempotency_expires_at")
  @@map("idempotency_keys")
}

/// Discounts table - stores discount codes and logic
model Discount {
  id             BigInt       @id @default(autoincrement()) @map("discount_id")
  code           String       @unique @db.VarChar(50)
  amount         Decimal      @db.Decimal(10, 2)
  type           DiscountType @default(PERCENTAGE)
  validFrom      DateTime     @default(now()) @map("valid_from") @db.Timestamp(6)
  validUntil     DateTime?    @map("valid_until") @db.Timestamp(6)
  usageLimit     Int?         @map("usage_limit")
  usageCount     Int          @default(0) @map("usage_count")
  minOrderAmount Decimal?     @map("min_order_amount") @db.Decimal(10, 2)
  eventId        BigInt?      @map("event_id")
  createdAt      DateTime     @default(now()) @map("created_at") @db.Timestamp(6)
  updatedAt      DateTime     @updatedAt @map("updated_at") @db.Timestamp(6)

  // Relations
  event Event? @relation(fields: [eventId], references: [id])

  @@index([code], map: "idx_discounts_code")
  @@index([eventId], map: "idx_discounts_event_id")
  @@map("discounts")
}

enum DiscountType {
  PERCENTAGE
  FIXED_AMOUNT
}
